Cache data using a shared object

A cache is a software component that stores data so that future requests for that data can be served faster. Side inputs, stateful DoFn and calling an external service can be used for accessing a cache. The Python SDK provide another option in the shared module, which can be more efficient that side inputs in terms of the amount of memory required or simpler than stateful DoFn.

The samples on this page show you how to use the Shared class in the shared module to enrich both bounded and unbounded PCollections. In both the samples, we assume two data sets - order and customer. The order records include customer IDs with which customer attributes are added by mapping the customer records.

Bounded PCollection example




Unbounded PCollection example


# The wrapper class is needed for a dictionary, because it does not support weak references.
class WeakRefDict(dict):
    pass

class EnrichOrderFn(beam.DoFn):
    def __init__(self):
        self._customers = {}
        self._shared_handle = shared.Shared()

    def setup(self):
        # setup is a good place to initialize transient in-memory resources.
        self._customer_lookup = self._shared_handle.acquire(self.load_customers)

    def load_customers(self):
        self._customers = expensive_remote_call_to_load_customers()
        return WeakRefDict(self._customers)

    def process(self, element):
        attr = self._customer_lookup.get(element["customer_id"], {})
        yield {**element, **attr}


# The wrapper class is needed for a dictionary, because it does not support weak references.
class WeakRefDict(dict):
    pass

class EnrichOrderFn(beam.DoFn):
    def __init__(self):
        self._max_stale_sec = 60
        self._cache_version = 0
        self._customers = {}
        self._shared_handle = shared.Shared()

    def setup(self):
        # setup is a good place to initialize transient in-memory resources.
        self._customer_lookup = self._shared_handle.acquire(self.load_customers, self._cache_version)
        self._cache_version +=1
 
    def load_customers(self):
        self._customers = expensive_remote_call_to_load_customers()
        return WeakRefDict(self._customers)

    def start_bundle(self):
        # Update the lookup table when the time difference exceeds the threshold.
        current_ts = datetime.now().timestamp()
        ts_diff = current_ts - self._customers["timestamp"]
        if ts_diff > self._max_stale_sec:
            self._customer_lookup = self._shared_handle.acquire(self.load_customers, self._cache_version)
            self._cache_version +=1

    def process(self, element):
        attr = self._customer_lookup.get(element["customer_id"], {})
        yield {**element, **attr}